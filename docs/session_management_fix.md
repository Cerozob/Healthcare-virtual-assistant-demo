# Session Management Fix

## Problem
The chat history was not working in the frontend because three different session IDs were being used inconsistently:

1. **MCP Session ID** - For Model Context Protocol level
2. **Runtime Session ID** - For AgentCore SDK level  
3. **Strands Session ID** - In the payload for the Strands agent

The first two (mcpSessionId and runtimeSessionId) were showing as `undefined` in console logs because they were being set to the same value as the Strands session ID, but weren't being persisted across requests.

## Solution

### 1. Added Persistent Session ID Storage
In `agentCoreService.ts`, added private properties to store session IDs:

```typescript
private mcpSessionId: string | null = null;  // Persistent MCP session ID
private runtimeSessionId: string | null = null;  // Persistent runtime session ID
```

### 2. Created Session ID Getters
Added methods to get or generate session IDs that persist across requests:

```typescript
private getMcpSessionId(): string {
  if (!this.mcpSessionId) {
    this.mcpSessionId = `mcp_${uuidv4()}`;
  }
  return this.mcpSessionId;
}

private getRuntimeSessionId(): string {
  if (!this.runtimeSessionId) {
    this.runtimeSessionId = `runtime_${uuidv4()}`;
  }
  return this.runtimeSessionId;
}
```

### 3. Added Reset Method
Created a public method to reset sessions when starting a new conversation:

```typescript
public resetSessions(): void {
  this.mcpSessionId = null;
  this.runtimeSessionId = null;
  console.log('ðŸ”„ Session IDs reset');
}
```

### 4. Updated Request Building
Modified the `sendMessage` method to use persistent session IDs:

```typescript
const mcpSessionId = this.getMcpSessionId();
const runtimeSessionId = this.getRuntimeSessionId();

const input: InvokeAgentRuntimeCommandInput = {
  agentRuntimeArn: runtimeArn,
  mcpSessionId: mcpSessionId,  // Persistent across requests
  runtimeSessionId: runtimeSessionId,  // Persistent across requests
  payload: new TextEncoder().encode(JSON.stringify(agentCorePayload))
};
```

### 5. Integrated with ChatPage
Updated `generateNewSession` in ChatPage to reset AgentCore sessions:

```typescript
const generateNewSession = (reason: string) => {
  const newSessionId = `healthcare_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  setSessionId(newSessionId);
  
  // Reset AgentCore session IDs (MCP and Runtime)
  import('../services/agentCoreService').then(({ agentCoreService }) => {
    agentCoreService.resetSessions();
  });
  
  console.log(`ðŸ”’ New session started: ${newSessionId} (Reason: ${reason})`);
  return newSessionId;
};
```

## How It Works Now

### Three Separate Session IDs:

1. **MCP Session ID** (`mcp_<uuid>`)
   - Generated once per conversation
   - Persists across all requests in the same conversation
   - Used for Model Context Protocol level tracking

2. **Runtime Session ID** (`runtime_<uuid>`)
   - Generated once per conversation
   - Persists across all requests in the same conversation
   - Used for AgentCore SDK level tracking

3. **Strands Session ID** (`healthcare_<timestamp>_<random>`)
   - Generated by frontend ChatPage
   - Sent in the payload to the Strands agent
   - Used for agent-level conversation tracking

### Session Lifecycle:

1. **Initial Load**: All three session IDs are generated
2. **Subsequent Messages**: MCP and Runtime IDs remain the same, Strands ID is maintained by ChatPage
3. **New Conversation**: All three IDs are reset when:
   - User clears patient context
   - User selects a different patient
   - User explicitly starts a new session

## Benefits

- **Consistent Session Tracking**: Each level (MCP, Runtime, Strands) has its own persistent session ID
- **Proper Chat History**: AgentCore can now properly track conversation history across requests
- **Clean Session Management**: Sessions are properly reset when starting new conversations
- **Better Debugging**: Console logs now show all three session IDs clearly

## Session ID Flow

### Overview

The system uses **two session ID concepts** that must be kept in sync:

1. **AgentCore Runtime Session ID** (`runtimeSessionId`) - Managed by the AWS SDK at the infrastructure level
2. **Strands Agent Session ID** (`sessionId`) - Managed by the Strands agent internally

Both IDs should have the **same value** to ensure proper session continuity across the entire stack.

### Frontend Request (agentCoreService.ts)

```typescript
// Generate or use provided session ID
const validSessionId = strandsRequest.sessionId || this.generateSessionId();

// Session ID goes in TWO places:
const agentCorePayload = {
  content: strandsRequest.content,
  sessionId: validSessionId  // 1. In payload for Strands agent
};

const input: InvokeAgentRuntimeCommandInput = {
  agentRuntimeArn: runtimeArn,
  runtimeSessionId: validSessionId,  // 2. In SDK for AgentCore
  payload: new TextEncoder().encode(JSON.stringify(agentCorePayload))
};
```

**Key Points:**
- Same `validSessionId` is used in both places
- `runtimeSessionId` is for AgentCore SDK session management
- `sessionId` in payload is for Strands agent internal use

### AgentCore SDK Processing

The AWS SDK receives:
- `runtimeSessionId`: Used for AgentCore session tracking
- `payload`: Contains the Strands-formatted request with `sessionId`

These are **independent** from AgentCore's perspective but should match for consistency.

### Agent Handler (main.py)

```python
# Extract session ID from payload
session_id = payload.get("sessionId", f"healthcare_session_{uuid4()}")

# Use for agent initialization and processing
agent = create_healthcare_agent(session_id)
```

## Testing

To verify the fix is working:

1. Open browser console
2. Send a message in the chat
3. Look for the log: "ðŸ”‘ Session ID Configuration:" (shows IDs being sent)
4. Verify all three session IDs are defined (not undefined)
5. Look for the log: "ðŸ”‘ Session ID Verification (Response):" (shows IDs received)
6. Verify MCP and Runtime session IDs match between sent and received (âœ… checkmarks)
7. Look for the log: "ðŸ”‘ Session ID Complete Analysis:" (comprehensive comparison)
8. Send another message
9. Verify MCP and Runtime IDs remain the same across requests
10. Select a different patient
11. Verify all session IDs are reset (new values generated)

### Expected Console Output

```text
ðŸ”‘ Session ID Configuration:
   â€¢ MCP Session ID: mcp_<uuid>
   â€¢ Runtime Session ID: runtime_<uuid>
   â€¢ Strands Session ID (in payload): healthcare_<timestamp>_<random>

ðŸ”‘ Session ID Verification (Response):
   â€¢ MCP Session ID (sent): mcp_<uuid>
   â€¢ MCP Session ID (received): mcp_<uuid>
   â€¢ MCP Match: âœ…
   â€¢ Runtime Session ID (sent): runtime_<uuid>
   â€¢ Runtime Session ID (received): runtime_<uuid>
   â€¢ Runtime Match: âœ…

ðŸ”‘ Session ID Complete Analysis:
   ðŸ“¤ Sent:
      â€¢ MCP Session ID: mcp_<uuid>
      â€¢ Runtime Session ID: runtime_<uuid>
      â€¢ Strands Session ID (payload): healthcare_<timestamp>_<random>
   ðŸ“¥ Received:
      â€¢ MCP Session ID: mcp_<uuid>
      â€¢ Runtime Session ID: runtime_<uuid>
      â€¢ Strands Session ID (payload): healthcare_<timestamp>_<random>
   âœ… Verification:
      â€¢ MCP preserved: âœ… YES
      â€¢ Runtime preserved: âœ… YES
      â€¢ Strands preserved: âœ… YES
```

If any session IDs show as `undefined` or don't match, there's an issue with the session management.
